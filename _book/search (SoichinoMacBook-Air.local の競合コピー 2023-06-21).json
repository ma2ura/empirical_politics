[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "計量会計学ノート",
    "section": "",
    "text": "はじめに\nこの本は、プレゼミのメインテキストである浅野・矢内 (2020)「Rによる計量政治学」の学習用ノートです。基本的に松浦が独学用に作成したノートのため、誤りや不備が多く含まれています。また、このノートは、浅野・矢内 (2020)の内容を網羅しているわけではありません。そのため、このノートだけで学習することはできません。このノートを使う場合は、浅野・矢内 (2020)を参照しながら学習することをおすすめします。\nなぜ会計学を専門とする松浦のプレゼミで、教科書が「Rによる計量政治学」なのかというと、このテキストが社会科学の一分野である政治学という経営学部生にとっても関連のある興味深い題材を用いて、計量経済学の基礎から応用までをRで実装するための知識を習得できるものだからです。\nとりわけ第1部の第2章「研究テーマの選び方」と第3章「理論と仮説」は、卒業論文を書く際にも非常に重要となる内容ですので、全経営学部生によんでもらいたい内容です。 第4章「Rの使い方」と第5章「Rによるデータ操作」は、本書の学習に必要な必要最小限の内容ですので、他の教科書やウェブサイトを参考にして、より詳細な内容を学習したほうが良いですが、この内容を理解し、使えるようになれば、MS Excelを使わずにRだけで分析できるようになるでしょう。\n第6章から第15章までが、統計学から計量経済学の内容となります。 おおよそ、代表的な統計量の計算や、グラフを使ったデータの理解、標本(sample)を用いた母集団(population)の推定や仮説検定、複数の統計量の関係性の理解、因果関係を分析する手法の1つである回帰分析の基礎と応用、2値選択の問題を推定するためのロジスティック関数の使い方などを学習します。\n2年生終了時点で、ここまでの内容を修得していれば、卒業論文の分析に必要な知識はほぼ習得できていると考えて良いでしょう。あとは関心のある研究テーマを選ぶために、面白そうな専門演習(ゼミ)に入って、Rと統計学・計量経済学を使った実証研究を楽しんでくれれば、プレゼミの目標が達成されます。\n教科書の目次は以下の通りです。"
  },
  {
    "objectID": "index.html#補足",
    "href": "index.html#補足",
    "title": "計量会計学ノート",
    "section": "補足",
    "text": "補足\n本書は、Posit社(以前はRstudio社)が開発したQuartoというソフトウェアを使って作成されています。Quartoとは、RMarkdownの記法で書かれたテキストファイルを、knitrというソフトウェアを介して、HTMLやPDF、MS Word、EPUBなどのファイルを作成するためのソフトウェアです。\n最大の特徴は、MS ExcelとMS Wordのようにデータを分析する場所と文章を書く場所が別々ではなく、一つの画面の中でデータ分析とレポート・論文執筆を同時に行える、というものです。\nまた、Rだけでなく、PythonやJuliaといった他のプログラミング言語も文章内に埋め込むことができるため、データ分析と文章執筆を統合させる環境として非常に優れています。 プレゼミでも、Quartoを使って最終レポートの作成を行う予定です。"
  },
  {
    "objectID": "Empoli_Chap01.html#会計を計量する",
    "href": "Empoli_Chap01.html#会計を計量する",
    "title": "1  計量会計学とは",
    "section": "1.1 会計を計量する？",
    "text": "1.1 会計を計量する？\nここでは、教科書「Rによる計量政治学」の内容を「会計学」に置き換えて考えてみます。 「計量会計学」という言葉は一般的ではなく、会計学の世界では「実証的会計研究」とか「実証会計」いう言葉が使われています。\n社会科学において、社会で生じる様々な現象（たとえば、経営現象や会計実務）を、数値化して分析することを計量化(quantification)と呼びます。軽量化されたデータを用いて、社会現象を説明しようとするアプローチを軽量分析(quantitative analysis)と呼びます。軽量分析の手法は、統計学や計量経済学などの数理的な手法を用いて、社会現象を説明しようとするものです。\nざっくりいうと、会計とは経営活動から生み出される価値の変化を貨幣的に計測・記録し、その情報を整理し、集約することで、最終成果物として報告書(たとえば貸借対照表など)を作成し、それを利害関係者に報告することで、投資意思決定に役立つ情報を提供したり、利害関係者間の利害調整を行うことを目的とした一連のプロセスを意味します。 つまり会計そのものが、経営現象を計量化することを目的としていると言えます。\nこの会計を研究対象とした学問を会計学(accounting)といい、会計学の中でも、会計情報といった計量化されたデータを用いた研究を(狭義の)実証的会計研究(archival based empirical accounting research)とか、単に実証会計といいます1 。\n国際的に評価の高い会計学の学術誌である、The Accounting Review(TAR)、Journal of Accounting and Economics(JAE)、Journal of Accounting Research(JAR)、Review of Accounting Studies(RAST)、Contemporary Accounting Research(CAR)の五大誌に掲載されている論文の大部分が、会計情報を用いた計量分析となっています。"
  },
  {
    "objectID": "Empoli_Chap01.html#分析的会計研究と実証的会計研究",
    "href": "Empoli_Chap01.html#分析的会計研究と実証的会計研究",
    "title": "1  計量会計学とは",
    "section": "1.2 分析的会計研究と実証的会計研究",
    "text": "1.2 分析的会計研究と実証的会計研究\n会計研究の世界では、1960年頃までは規範的研究(normative research)という「〇〇するべき」という主張をする研究が主流でした。たとえば企業が保有する株式を時価評価すべきか、やある特徴をもつリース資産を購入したものとして扱うべきか、といったものです。\nしかし、1968年にJournal of Accounting Researchに掲載されたBall and Brown (1968) An Empirical Evaluation of Accounting Income Numbersを皮切りに、実際に会計情報は投資家の役に立っているのかをデータを使って確かめる、という、いわゆる実証研究が行われるようになり、今日まで会計研究の主流となっています。\nまた分析的会計研究は、そもそも要求される研究能力が相対的に高く、また研究に要する時間も長いため、実証的会計研究に比べて研究者の数が少ないという特徴がありますが、理論と実証は研究の両輪をなすものであり、どちらも重要であることに違いはありません。 ただやはり難しい数式が出てくる会計研究は理解できないので、ここでは実証的会計研究について考えていきます。ヴィトゲンシュタインの言葉を借りれば、語り得ないものは語らないということで、分析的会計研究は沈黙するべきでしょう。"
  },
  {
    "objectID": "Empoli_Chap03.html#よい理論とは",
    "href": "Empoli_Chap03.html#よい理論とは",
    "title": "3  理論と仮説",
    "section": "3.1 「よい理論」とは？",
    "text": "3.1 「よい理論」とは？\n実証研究のリサーチ・デザイン(research design)のプロセスは次のような手順になります。\n\nパズルを見つける（簡単には見付からないです）\nパズルを説明するための複数の前提条件を使って理論を作る。（前提条件を自分で考えるのは難しすぎるので、先行研究を参考にすることが多いです。理論はパズルを説明するための仮説の集合体です。）\n理論から作業仮説(working hypothesis, hypothesis)を引き出す。\n作業仮説を顕彰するためのデータを集める。\nデータを使って作業仮説を検証し、理論の妥当性を確かめる。\n\n理想的にはこうなるでしょうが、現実にはこんなにうまくいきませんが、この講義では3〜5のプロセスを重視します。というのも、1と2のステップはかなり難しいので、現実には、\n\n興味のある経営現象を見つけて調べる。\n経営現象の発生を説明するための理論を見つけるために、先行研究を漁る。\n先行研究を参考にして作業仮説を作る。\n\nという風に行われることが多い（と思います。たぶん）\n\n3.1.1 因果法則の3つの条件\n因果関係(causality)と相関関係(correlation)の違いを理解しておきましょう。\n因果関係とは、原因(causal)と結果(outcome)の関係のことです。正確に言うと、ある要因Xを操作するとき、別の要因Yが変化することです(Imbens and Rubin, 2015, p.4)。\n因果関係を考える際には、「効果をもたらした原因」(causal of effect)と「原因のもたらす効果」(effect of cause)の両方があります。例えば、ある企業が従業員の給料を上げたとします。このとき、従業員の給料が上がったことが「効果をもたらした原因」であり、従業員の給料が上がったことによって、従業員のモチベーションが上がったことが「原因のもたらす効果」です。 定量的な研究では、「原因のもたらす効果」を分析することが多いです。\n因果関係があると考えるためには、3つの条件を確かめる必要があります。\n\n原因が結果より先に起こる。\n原因と結果が共変する。\n原因以外の重要な要因が変化しない。\n\nこの因果関係を記述するものを理論といいます。\n\n\n3.1.2 理論とは\n理論とは「原因と結果について一般的な論述」で、「〇〇であるとき、△△が起こる」というようなものです。推論といってもよいです。 原因と結果の関係を「説明変数X」(explanatory variable)と「応答変数Y」(response variable)の関係として表現します。\n\nX \\Longrightarrow Y\n\n推論を作る際には，どれだけ説得力があり納得できる仮定を設定するかが重要となります。仮定のない推論など役に立たないからです。 経営学は独自の理論をもたない学問とも言われ，とりわけ会計学における事実解明的研究(positive research)では，心理学や経済学で蓄積された理論を借用することが多いです（松浦は経済学に基づく推論を行っています）。\n\n\n3.1.3 良い理論とは？\n良い理論・推論が持つべき性質は次のようなものです。\n\n反証可能であること\n観察可能な予測が多いこと\n具体的であること\nシンプルであること\n\n\n反証可能であること\n「反証可能性」(falsifiability)という科学で最も重要な特性の1つを確保する必要があります 1 。\nつまり，論文を読んだ人ならだれでも，「この理論は間違っている」ということを示すことができるようにする必要があります。反証可能性がない主張は占いと変わりません。\n\n\n観察可能な予測が多いこと\n結果として発生する現象が観察可能である予測を行う必要があることを示しています。 当然ですが，自分の主張を証拠を用いて説得力を高めようとしているのですから，その予測が当たっているのかどうかを確認できる必要があります。\n\n\n具体的であること\n「業績が悪くなる」のようにあいまいな表現ではなく，「昨年度と比べて利益が減少する」とか「累積リターンがマイナスになる」といったように，具体的な予測を行う必要があります。\n\n\nシンプルであること\n理論はシンプルでなければなりません。 理解しやすく，使える範囲が広く，反証可能性が高い理論は，シンプルになっていきます。\n基本的には，先行研究で使われている理論を援用することが多い経営学・会計学では，先行研究で用いられた理論や推論に無駄がないかどうか，よりシンプルにいえないかどうか，を考えることが多いです。\n理論をシンプルにするには，前提となる条件を少なくする必要があります。 観察された経営現象をそのまま記述しようとすると非常に長く，複雑な文章になるでしょう。 それでは何が本質的に重要か分からないので，経営現象を抽象化・単純化することで，本質以外のものをそぎ落とし，理論をシンプルにすることがで，経営現象への理解がより深まります(オッカムの剃刀)。"
  },
  {
    "objectID": "Empoli_Chap02.html#リサーチクエスチョンの種類",
    "href": "Empoli_Chap02.html#リサーチクエスチョンの種類",
    "title": "2  研究テーマの選び方",
    "section": "2.1 リサーチ・クエスチョンの種類",
    "text": "2.1 リサーチ・クエスチョンの種類\nリサーチ・クエスチョン(research question)とは、研究対象となる会計に関する、抽象度の高い問いのことです。 リサーチ・クエスチョンが決まれば、その問いに答えるために、何をするべきなのかが決まるため、非常に重要な要素となります。 たとえば、\n\n会計情報の質が高いと、投資家の意思決定がよりよいものになるのか？\n大きな監査法人は、財務報告の質を高めているのか？\nCSR活動に積極的な会社は、納税も積極的か？\nのれんは償却するべきか？\nIFRS採用企業と非採用企業の違いはあるのか？\nコロナ禍における利益圧縮活動は行われたのか？\n\nこれらのリサーチ・クエスチョンを3つに分類してみましょう。\n\n2.1.1 実証的問題\n実証的問題では、事実を調べることが目的となります。 たとえば、「のれんの非償却はM&Aを促進させるのか」という問いに対しては、のれんの非償却を行っている企業と、行っていない企業のM&Aの実施率を比較することで、その問いに答えることができます。 実証的問題を扱う会計研究でも、定量的な研究だけでなく、インタビューによる定性的な研究もあります。参与観察研究はあまり見ません。 事実に注目する研究となるため、主観的な要素はできるだけ排して、観察されたデータや発言といった客観的なデータを用いることが多いです。\n\n\n2.1.2 規範的問題\nいわゆる「べき論」を扱う問題で、日本の会計研究では今でも盛んに行われている研究です。 たとえば、「のれんは償却すべきか」という問いに対しては、のれんの償却を行うことで、どのようなメリットがあるのか、どのようなデメリットがあるのかを考え、そのメリットとデメリットを比較することで、その問いに答えることができます。 ただ、この場合でも、「誰にとっての」メリットを重視するべきなのか、という問題がでますが、そこは研究者の価値判断によって決まることになり、研究者の主観が大きく反映されることになります。\nしたがって本教科書でも、規範的問題を実証的問題に変換する方法を考えます。\n\n\n2.1.3 分析的問題\n分析的問題は、まだ起こっていない、観察されていない現象を扱います。 そもそも起こっていない現象なのでデータも取りようがありません。 そこで、分析的問題では、モデル(model)を用いて、現象の起こりうるメカニズムを考えます。\n基本的には、関心のある問題を抽象化して数式で表現し、前提条件と仮定を設定し、その問題を解くことで得られた結果を解釈することで、その問いに答えることができます。 たとえば、税務会計や監査といった情報が入手困難な領域において、ゲーム理論や契約理論、最適化理論を用いた分析が行われることが多いような気がしますが、そこまで詳しくないです。"
  },
  {
    "objectID": "Empoli_Chap02.html#よい研究テーマの見つけ方",
    "href": "Empoli_Chap02.html#よい研究テーマの見つけ方",
    "title": "2  研究テーマの選び方",
    "section": "2.2 「よい研究テーマ」の見つけ方",
    "text": "2.2 「よい研究テーマ」の見つけ方\n政治学のMonroe (2000, pp.8–10)によると、\n\n明快さ\n検証可能性\n理論的重要性\n実用性\n独創性\n\nがよい研究テーマに必要な要素です。詳しくは教科書を読むとして、会計学や経営学でもほぼ同じですが、卒業論文においては、理論的重要性と独創性はあればよいですが、必ずしも必要ではありません。なぜなら、理論的重要性を理解し、論文で示すことは、研究で用いる推論の背後にある理論や仕組みを完全に理解する必要がありますし、独創性を主張するためには、膨大な先行研究を読み、自分の主張が他の人とどう違うのか、どの点が新しいのかを明らかにする必要があり、とても時間がかかるからです。\nしたがって、明快な推論で導き出された仮説を、客観的なデータを用いて、適切な手法で分析し、その結果を解釈し、経営実務にどういう影響があるのか、を主張できれば、卒業論文としては申し分ないレベルです。\nとりわけ、このプレゼミでは、検証可能性を重視します。 そのレポート・論文を読めば、他の人でも同じ分析を行うことが可能であり、誰でも追試が行えることが重要です。 データの集め方や変数の作り方、データ分析のプロセスが明確にしめされており、それを自分でもすぐに再現することが重要です。そのためにRは非常に有効なツールとなります。\n\n2.2.1 規範的問題から実証的問題への変換\n「べき論」は研究者の価値判断が大きく反映され、その研究者が主張する価値は主観的なものになるため検証ができません。 そこで規範的問題を実証的問題になるように問い方を変える方法を考えます。\n\n2.2.1.1 参照枠組みを変える\n「会計は投資意思決定に役立つべきである」という問いは規範的問題で、それは「会計は株主のためのものである」という価値判断が含まれています。このままでは検証できないので、「会計は投資意思決定に役に立っているのか？」に変えることで、検証可能な問いになります。\n\n\n2.2.1.2 規範的問題の背後にある前提条件に注目する\n「会計は投資意思決定の役立つべきである」という規範的記述の背後には、\n\n会計は投資家のためのものである\n投資家が会計(情報)を使えば儲かる。\n投資家の投資が活発になれば、経済は活性化する。\n\nという前提条件があると考えられます。\nこれを実証的な問題にするには、\n\n会計(情報)の主な利用者は投資家なのか？\n会計情報を使えば儲かるのか？\n投資の役に立つ会計情報を提供することで、経済は活性化するのか？\n\n\n\n\n2.2.2 パズルを探す\nパズル(puzzle)とは、ある現象を説明するために、既存の理論では説明できない現象のことです。たとえば、配当パズル(dividend puzzle)とは、配当がなぜ存在するのか、という問題です。配当は、株主に対する利益配分の一つであり、株主にとっては配当が高いほうがよいはずです。しかし、実際には、配当が高いほど株価が低くなるという現象が観察されます。\n\n\n2.2.3 研究論文の構成\n論文の構成\n\nイントロダクション\n先行研究\n理論\n仮説\n対抗仮説\n作業化\n証拠\n結論"
  },
  {
    "objectID": "Empoli_Chap03.html#仮説と仮説検証",
    "href": "Empoli_Chap03.html#仮説と仮説検証",
    "title": "3  理論と仮説",
    "section": "3.2 仮説と仮説検証",
    "text": "3.2 仮説と仮説検証\n\n3.2.1 仮説とは\n科学的には，「理論」と「仮説」とは同じものです。反証されずに生き残った理論を仮説(hypothesis)と呼びます。\nこの「仮説」をより具体的にしたものを「作業仮説」(working hypothesis)と呼びます。\n\n作業仮説とは，自分が使える特定の変数についての記述\n「もしこの仮説が正しければ・・・のはず」\n理論より作業仮説の方が具体的である\n仮説から引き出される観察可能な予測について述べる\n\n\n\n3.2.2 作業仮説\nたとえば「監査の質が高いほど，財務報告の質が高くなる」という理論から，作業仮説を引き出してみましょう。 この文章の中で，\n\n監査の質\n高い\n財務報告\n高い\n\nという4つの用語を，測定可能な尺度にして，その高低を定義する必要があります。\nたとえば，監査の質を「監査報酬額」で測定して，財務報告の質を利益操作の程度で測定するとします。利益操作の程度をアクルーアルで代理すると\n\n監査報酬が高い企業ほど，アクルーアルの絶対値が小さい"
  },
  {
    "objectID": "Empoli_Chap03.html#footnotes",
    "href": "Empoli_Chap03.html#footnotes",
    "title": "3  理論と仮説",
    "section": "",
    "text": "「反証不可能な理論は科学ではない」といったのは，科学哲学者カール・ポパー(Karl Popper)です。 Popper (1959) The Logic of Scientific Discovery, London: Hutchinson.↩︎"
  },
  {
    "objectID": "Empoli_Chap05.html#データの読み込み",
    "href": "Empoli_Chap05.html#データの読み込み",
    "title": "5  Rによるデータ操作",
    "section": "5.1 データの読み込み",
    "text": "5.1 データの読み込み\n\n5.1.1 CSVファイルの読み込み\n多くのプログラミング言語で、読み込むデータとして最も多いのが、CSV形式のファイルです。ファイルの拡張子は.csvです。 CSVとは、Comma Separated Valuesの略で、カンマで区切られたデータのことです。 次のような形をしています。\n企業ID,決算年月,売上高\n13,2020/03,1000\n13,2021/03,1200\n13,2022/03,1500\n24,2020/03,2000\n24,2021/03,2200\n24,2022/03,2500\n33,2020/03,3000\n33,2021/03,3200\n33,2022/03,3500\nこのように、値とコンマ,のみで構成されたファイルのため、余計な情報が入っておらず、またファイルサイズも小さく、加工が簡単なので、データのやり取りによく使われます。\nではファイルを読み込んでみます。ここでは、松浦のウェブサイトにあるデータkeshohin_2023.csvを読み込んでみます。 Rの場合は、read.csvという関数を使って、URLを直接指定して読み込むことができます。読み込んだデータをdfという変数に代入しています。\nExcelの場合は、インターネット上のデータを直接取り込むことは難しいので、いったんパソコンの中に保存してから、ファイルを開くとします。\n\n\n\n\n\n\nRの場合\n\n\n\n\ndf &lt;- read.csv(\"https://so-ichi.com/kesho_2023.csv\")\n\n\n\n\n\n\n\n\n\nMS Excelの場合\n\n\n\n\nURLhttps://so-ichi.com/kesho_2023.csvをブラウザに入力してファイルをダウンロードし、任意の場所に保存\n「ファイル」から「開く…」をクリックして、保存したCSVファイルを選択し「開く」をクリック\n\n\n\n\n\n5.1.2 Excelファイルの読み込み\nMS Excelのファイルは拡張子が.xlsx、古いMS Excelだと.xlsです。 RでExcelファイルを読み込むときは、read_excelという関数を使います。 Excelファイルを用意するのが面倒なので、ここではこうやれば読み込めるよ、というコードだけ説明します。ファイル名はhoge.xlsxとします。\n\n\n\n\n\n\nRの場合\n\n\n\n\ndfx &lt;- readxl::read_excel(\"hoge.xlsx\")\n\n\n\n\n\n\n\n\n\nMS Excelの場合\n\n\n\n\n「ファイル」から「開く…」をクリックし、保存してあるExcelファイルを選択し「開く」をクリック\n\n\n\nMS Excelの問題点は、目的のデータがどのExcelファイルに入っていて、それがどこに保存されているのかを覚えておかないと、いちいちファイルを開いて探さないといけないことです。\nRだとソースコードを残すことができますので、 どこにあるファイルを読み込んで、そこに何が入っているのかをコメントで残しておくことができます。"
  },
  {
    "objectID": "Empoli_Chap05.html#読み込んだデータの確認",
    "href": "Empoli_Chap05.html#読み込んだデータの確認",
    "title": "5  Rによるデータ操作",
    "section": "5.2 読み込んだデータの確認",
    "text": "5.2 読み込んだデータの確認\nMS Excelは読み込んだデータが画面上に表として表示されていますが、Rでは変数に代入しただけでは、画面には何も表示されません。 そこでデータの中身を確認する関数として、次のようなものがあります。\n\nhead() : 最初の数行を表示させる基本関数\nstr() : データの構造を表示させる基本関数\nglimpse() : データの構造を表示させるdplyrパッケージの関数\nnames() : 変数名を表示させる基本関数\n\nこれらを使って、データの中身を確認し、データの形に適した処理方法を学ぶ必要があります。 以下では、head()関数を使って、データの最初の数行を表示させてから、str()関数でデータの中の変数とその型を確認します。\nExcelは目視が中心ですが、見ただけでは、文字列なのか数なのかが分からないので、やはりデータの型は確認する必要があります。\n\n\n\n\n\n\nRの場合\n\n\n\n\nhead(df)\n\n  code   name    term shubetsu ren  sales netincome month\n1  641 資生堂 1985/11       10   1 371040     14526    12\n2  641 資生堂 1986/11       10   1 375294     13632    12\n3  641 資生堂 1987/11       10   1 378977      9014    12\n4  641 資生堂 1988/11       10   1 401311      9515    12\n5  641 資生堂 1989/03       10   1 130654      4265     4\n6  641 資生堂 1990/03       10   1 456352     11362    12\n\nstr(df)\n\n'data.frame':   130 obs. of  8 variables:\n $ code     : int  641 641 641 641 641 641 641 641 641 641 ...\n $ name     : chr  \"資生堂\" \"資生堂\" \"資生堂\" \"資生堂\" ...\n $ term     : chr  \"1985/11\" \"1986/11\" \"1987/11\" \"1988/11\" ...\n $ shubetsu : int  10 10 10 10 10 10 10 10 10 10 ...\n $ ren      : int  1 1 1 1 1 1 1 1 1 1 ...\n $ sales    : int  371040 375294 378977 401311 130654 456352 517252 553299 561549 549178 ...\n $ netincome: int  14526 13632 9014 9515 4265 11362 15850 16011 13290 14668 ...\n $ month    : int  12 12 12 12 4 12 12 12 12 12 ...\n\n\n\n\n\n\n\n\n\n\nMS Excelの場合\n\n\n\n画面を見て確認する。\n\n\nこのデータには，\n\ncode : 企業コード (文字列)\nname : 企業名 (文字列)\nterm : 決算年月 (文字列)\nshubetsu : 会計基準の種類 (数値)\nren : 連結か単体 (数値)\nsales : 売上高 (数値)\nnetincome : 当期純利益 (数値)\nmonth : 決算月数 (数値)\n\nが入っています。"
  },
  {
    "objectID": "Empoli_Chap05.html#データの整形",
    "href": "Empoli_Chap05.html#データの整形",
    "title": "5  Rによるデータ操作",
    "section": "5.3 データの整形",
    "text": "5.3 データの整形\n\n5.3.1 データ操作の基礎\nさあ面白くなってきました。 次はデータを操作していきます。 Rによるデータ操作では、tidyverseパッケージ群のdplyrパッケージが大活躍します。\ndplyrパッケージの関数の中でもよく使うものに次のようなものがあります。\n\nselect() : 変数を選択する\nfilter() : データを抽出する\nmutate() : 変数を追加する\narrange() : データを並び替える\nsummarise() : データを集計する\ngroup_by() : データをグループ化する\n\n\n\n5.3.2 パイプ演算子\nRでソースコードを書く際に，理解しやすく，読みやすいコードにするために非常に便利なのが，パイプ演算子%&gt;%です。 パイプ演算子%&gt;%は，左側のオブジェクトを右側の関数の第一引数に渡すという処理を行います。 たとえば，\n\n(1 + 2) %&gt;% sqrt()\n\n[1] 1.732051\n\n\nと書くと，sqrt(1 + 2)と同じ意味になります。 たとえば，rnorm()関数を使って平均0，分散1の標準正規分から100個のデータを作りたいとします。 rnorm()関数は3つの引数を取ります。\n\nデータの個数\n平均\n標準偏差\n\nしたがって，rnorm(100, 0, 1)と書くと，平均0，分散1の標準正規分布から100個のデータを取り出すことができます。 パイプ演算子を使うと，\n\n100 %&gt;% rnorm(mean = 0, sd = 1)\n\n  [1]  2.02098289 -0.01567589  0.15159671  0.25778923 -1.38789405 -0.96028000\n  [7] -0.62912821 -0.04270311  0.22528622  1.68275807 -0.94537580 -0.40561502\n [13]  0.05331148  0.72160469 -0.01756827 -1.06325381 -0.03343546  1.00321681\n [19] -0.38198565  1.49742104  0.55100865  0.66952080  0.54989461  0.65121238\n [25] -0.07506911 -0.38576495  0.01219652  0.29980537 -0.45429946  0.63678530\n [31]  1.78394311  1.77194720 -0.34038288 -1.18337434 -1.79364845  0.10026490\n [37] -2.61258387  0.78334820  0.95621964 -1.34816037 -2.08444166  1.65247988\n [43] -1.07970665 -0.22145043 -0.91265998  0.01654933 -0.78168947  3.19711303\n [49] -1.49518796 -1.92111855 -1.26354892  2.38514420  0.02513105 -0.39064926\n [55]  1.27447458 -0.84663064 -0.92110365 -1.14568245  0.51829520  0.08322748\n [61] -0.22657199 -0.23424784  1.51322048  1.35188482 -1.04573789 -1.51522853\n [67]  0.14801748  0.40871578 -0.63200582  0.94535218  1.10491897  0.68333340\n [73] -0.03745843  0.68080519 -0.16254380 -0.96087029  0.09110569 -0.61514941\n [79] -0.15460568 -1.83845407  0.31323268  1.14365399 -1.97327727  0.88112748\n [85] -0.52354804 -2.27717328  0.07460471  0.13076830 -0.59640832 -0.83443571\n [91]  0.15197046 -0.80717829  0.06020061 -0.34070526 -0.31337371  0.56701534\n [97] -1.33869704 -0.51786763  0.33582848 -1.58718725\n\n\nとなります。 これはrnorm()関数の第1引数がデータの個数なので，そこに100を渡しています。 ここで平均に値を渡したい場合を考えます。 mean引数は第2引数なので，パイプ演算子では自動で渡してくれません。 そこで.を使って渡す場所を指定してあげます。\n\n100 %&gt;% rnorm(100, mean =. , sd = 1)\n\n  [1] 100.57811 101.13941  98.63739 100.04955 100.10685  99.90529  98.55498\n  [8]  99.37187 100.54730 100.92290 100.46077  99.36059  99.47082  98.84983\n [15]  99.55702  99.78606  99.33123 100.08131 103.04744  99.37914 102.13397\n [22] 100.18628 101.57551 100.38801 100.88334  99.31324  97.78506  99.18476\n [29]  99.91592  98.94678 100.26314  97.22525  99.32539 100.87064 100.19106\n [36]  99.54950  99.42282  98.35240 100.79855 101.24605  98.50947 100.26702\n [43] 100.35572 100.55771 100.24754 100.24274  99.57423  99.88489 101.63059\n [50] 101.16415 100.45155  99.86209 101.06982  99.85424  98.87627 100.24307\n [57] 100.71526  98.82500  99.07848 100.23008 101.05091 100.23221 101.17351\n [64] 100.05771  99.46782  99.84655 101.54824 100.35373  97.87418  99.40525\n [71] 100.63076  98.68811  99.67398 100.27721  99.77991  99.72222 100.06803\n [78] 100.28806  98.31865  98.29058 100.40161 100.24905 100.07623  99.70658\n [85]  99.25663  99.22017 100.39887 101.70582 100.32119 100.74222  99.30291\n [92] 100.01350 101.50755  99.61240 100.93681  99.98940 101.20864  99.05292\n [99]  99.07668 100.30761\n\n\nこれで平均100，標準偏差1の正規分布から100個のデータを取り出せました。\nこれだけだと便利さが伝わらないので，たとえば次のような処理を考えてみましょう。\n\n2020年のデータを抜き出し，\n売上高当期純利益率を計算し，\n産業グループごとに平均を計算する\n利益率が高い順番に並び替える\n\nをパイプ演算子を使って書くと，\n\ndf &lt;- df %&gt;%\n    filter(term == \"2020\") %&gt;% # 2020年のみ\n    mutate( # 新しい変数を作成\n        ratio = netincome / sales # 売上高利益率\n        ) %&gt;%\n    group_by(sangyo) %&gt;% # 産業グループごとに\n    summarise( # 平均を計算\n        mean_ratio = mean(ratio) # 利益率の平均\n        ) %&gt;%\n    arrange(desc(mean_ratio)) # 利益率の高い順に並び替え\n\nのように，上から順番に処理を実行し，次に渡す，というプロセスが分かりやすく，読みやすいコードができました。 コメントも残しておけば，後から見返したときにも分かりやすいですし，他人によんでもらうときも親切ですね。 したがって，以下ではパイプ演算子を駆使して，データ操作を行っていきます。\n\n\n新しい変数を作成する mutate\n新しい変数を作成するには，dplyrパッケージのmutate()関数を使います。 先ほど読みこんだデータから，当期純利益を売上高で除して売上高当期純利益率を計算して，ratioという変数を作ってみましょう。\n\n\n\n\n\n\nRの場合\n\n\n\n\ndf &lt;- df %&gt;%\n    mutate( # 新しい変数を作成\n        ratio = netincome / sales # 売上高利益率\n        )\n\n\n\n\n\n\n\n\n\nMS Excelの場合\n\n\n\nI1のセルに変数名を表すratioと入力する。 F列のsaleとG列のnetincomeを使って，I2のセルに\n= G2 / F2\nとし，I2セルの右下の四角をダブルクリックすると，自動で下のセルにも同じ計算がコピーされる。\n\n\n次に，ある変数の値に応じて異なる値をとる変数を作るには，mutate()関数とifelse()関数を同時に使います。ifelse()関数は次のような引数を取ります。\n\nifelse(条件, 条件が真のときの値, 条件が偽のときの値)\n\n先ほど計算した売上高当期純利益率が5%以上ならば「高い」，そうでなければ「低い」という変数highlowを作ってみましょう。\n\n\n\n\n\n\nRの場合\n\n\n\n\ndf &lt;- df %&gt;%\n    mutate( # 新しい変数を作成\n        highlow = ifelse(ratio &gt;= 0.05, \"高い\", \"低い\") # 売上高利益率\n        )\n\n\n\n\n\n\n\n\n\nMS Excelの場合\n\n\n\nJ1セルにhighlowと入力する。 J2セルに\n= if(I2 &gt;= 0.05, \"高い\", \"低い\")\nと入力し，J2セルの右下の四角をダブルクリックすると，自動で下のセルにも同じ計算がコピーされる。\n\n\nExcelだとセルの移動や変数名の入力，計算式の入力，セルのコピーといった作業で，キーボードとマウスを行ったり来たりする必要があり，若干面倒です。\nついでに，mutate()関数を使って，長すぎる企業名を短くしてみます。 ここでは「ポーラ・オルビスホールディングス」を「ポーラ」と略してみます。 mutate()とifelseを使って，name変数の値が「ポーラ・オルビスホールディング」ならば「ポーラ」という値をとる変数name上書きします。を作ってみましょう。 :::{.callout-important} ## Rの場合\n\ndf &lt;- df %&gt;%\n    mutate( # 新しい変数を作成\n        name = ifelse(\n            name == \"ポーラ・オルビスホールディング\", \"ポーラ\", name) # 企業名\n        )\n\n\n\nデータを抽出する filter\nデータを抽出するには，dplyrパッケージのfilter()関数を使います。 filter()関数は，次のような引数を取ります。\n\nfilter(データ, 条件)\n\n先ほど作成したratio2が「高い」企業だけを抽出してみましょう。 filter()関数の中の条件は，==を使って，\"高い\"という文字列と一致するかどうかを確認しています。 ここでは，highlow変数の値が\"高い\"と一致する企業だけを抽出し，df_highという変数に代入しています。 :::{.callout-important} ## Rの場合\n\ndf_high &lt;- df %&gt;%\n    filter(highlow == \"高い\") # 条件\n\n:::\n\n\n\n\n\n\nMS Excelの場合\n\n\n\nhighlow変数のあるJ列をクリックして枠を移動させ，上の「ホーム」メニューから「並び替えとフィルター」をクリックし，「フィルター」をクリックする。 すると，変数名highlowのヨコに漏斗のようなマークが出るので，それをクリックすると，記録されたデータの種類が出てくるので，「高い」だけにチェックが入った状態にする。\n\n\nExcelのクリック回数が増えてきましたね。\nfilter()関数の中で指定する条件は，\n\n== : 一致する\n!= : 一致しない\n&gt;=や&lt;= : 以上や以下\n&gt;や&lt; : より大きいや小さい\n%in% : いずれかに一致する\n\nなどがあります。またこれらの条件を組み合わせることもできます。 その場合は，以下のように&や|を使います。\n\n& : かつ\n| : または\n\nたとえば，資生堂と花王を抽出したり，売上高当期純利益率が5%以上かつ売上高が1000億円以上の企業を抽出するには， 次のように書きます。\n\n\n\n\n\n\nRの場合\n\n\n\n\ndf_shiseido_kao &lt;- df %&gt;%\n    filter(name %in% c(\"資生堂\", \"花王\")) # 2社だけ抽出\ndf_high2 &lt;- df %&gt;%\n    filter(ratio &gt;= 0.05 & sales &gt;= 1000) # 2条件を同時に満たす\n\n\n\n\n\n変数を選択する select\nデータの中から必要な変数だけを選択するには，dplyrパッケージのselect()関数を使います。 たとえば，先ほど作成したdfから，企業コード，企業名，売上高当期純利益率の3つの変数だけを選択してみましょう。\n\n\n\n\n\n\nRの場合\n\n\n\n\ndf3 &lt;- df %&gt;%\n    select(code, name, ratio) # 3つの変数だけ選択\n\n\n\n\n\n\n\n\n\nMS Excelの場合\n\n\n\nオリジナルのデータをコピーして，下のタブから別のシートを選択し，そこに貼り付ける。\n貼り付けたデータからcodeとnameとratio以外の列を削除する。\n\n\nMS Excelだと，不要なデータを削除するのが怖い作業で，必要になったときにまた元のデータを読み込まないといけないので，面倒ですし，ミスのもとです。\nselect()関数の中で使えるものには，以下のようなものがあります。 とても便利なので，覚えておくとよいでしょう。\n\n- : 除外する (-ratioとかくとratio以外を選択)\n: : 連続する変数を選択 (code:renと書くとcodeからrenまでを選択)\nstarts_with() : ある文字列で始まる変数を選択\nends_with() : ある文字列で終わる変数を選択\n\nたとえば，mutate()で新しい変数を作る場合に，変数名に法則性をつけておけば，starts_with()を使って一気に変数を選択することができます。 たとえば，比率を表す変数はratioで始まるように統一しておく，基準化した変数には_Kを最後に付けておく，などです。\n\n\nデータを並び替える arrange\nデータを並び替えるには，dplyrパッケージのarrange()関数を使います。 たとえば，先ほど作成したdfから，売上高当期純利益率を並び替えてみましょう。\n\n\n\n\n\n\nRの場合\n\n\n\n\ndf %&gt;%\n    select(name, ratio) %&gt;% # 2つの変数だけ選択\n    arrange(ratio) %&gt;%\n    head()\n\n    name       ratio\n1 ポーラ -0.43495809\n2 資生堂 -0.07576384\n3 資生堂 -0.03859062\n4 資生堂 -0.02166802\n5 資生堂 -0.01384122\n6 資生堂 -0.01266169\n\n\n\n\n小さい順に並び替えられました。 大きい順にするには，desc()関数を使います。 ついでにknitrパッケージのkabble()関数で表を見やすく加工してみます。\n\n\n\n\n\n\nRの場合\n\n\n\n\ndf %&gt;%\n    select(name, ratio) %&gt;% # 2つの変数だけ選択\n    arrange(desc(ratio)) %&gt;%\n    head(10) %&gt;% # 先頭の10行\n    knitr::kable(booktabs = TRUE) # 表をきれいに表示\n\n\n\n\nname\nratio\n\n\n\n\nポーラ\n0.1110647\n\n\n花王\n0.1019213\n\n\n花王\n0.0987028\n\n\n花王\n0.0986613\n\n\nユニ・チャーム\n0.0929384\n\n\n花王\n0.0912752\n\n\nポーラ\n0.0895507\n\n\nユニ・チャーム\n0.0891383\n\n\nユニ・チャーム\n0.0890311\n\n\nユニ・チャーム\n0.0869777\n\n\n\n\n\n\n\nこれでどの企業のどの年度の売上高当期純利益率が大きいのかが一目瞭然になりました。\nMS Excelだと，\n\n\n\n\n\n\nMS Excelの場合\n\n\n\n「ホーム」メニューから「並び替えとフィルター」をクリックし，「昇順」をクリックする。\n必要なデータだけ選択してコピペすれば，表が完成します。\n\n\nとなります。 簡単ですが，MS Excelの並び替えは注意が必要で，並び替えた後にデータを追加すると，並び替えが解除されてしまい，元に戻せなくなったり，空列があると並び替えがうまくいかなかったりします。\n\n\n5.3.3 long形式とwide形式\n人間には読みやすいけれどパソコンは読みにくい，というデータの形式があります。 例えば下の表を見てみましょう。\n\n\n\n地点\n6時\n12時\n18時\n\n\n\n\n札幌\n12℃\n15℃\n13℃\n\n\n大阪\n20℃\n24℃\n22℃\n\n\n福岡\n23℃\n25℃\n25℃\n\n\n\nこのような形のデータをワイド形式(wide)といいます。 天気予報で見かけそうなこの表は，人間にとっては分かりやすいですが，実はコンピュータにとっては，分かりにくいものです。 コンピュータが理解しやすいデータとして表すなら，次のような表になります。\n\n\n\n地点\n時間\n気温(℃)\n\n\n\n\n札幌\n6時\n12\n\n\n札幌\n12時\n15\n\n\n札幌\n18時\n13\n\n\n大阪\n6時\n20\n\n\n大阪\n12時\n24\n\n\n大阪\n18時\n22\n\n\n福岡\n6時\n23\n\n\n福岡\n12時\n25\n\n\n福岡\n18時\n25\n\n\n\nこのような形式のデータをロング型(long)といいます。 このロング型のうち，一定のルールに従って作成されたデータを整然データ(tidy data)といい，Rでは，この整然データを扱うことが多いです。\nR神Hadley Wickham氏は，データの型を理解することを，データ分析の第一歩とし，その一貫として整然データという考え方を提唱しています。 整然データとは，次のような原則に従って構築されたデータのことです(Wickham, 2014) 参考[https://id.fnshr.info/2017/01/09/tidy-data-intro/]。\n\n個々の変数 (variable) が1つの列 (column) をなす。\n個々の観測 (observation) が1つの行 (row) をなす。\n個々の観測の構成単位の類型 (type of observational unit) が1つの表 (table) をなす。\n個々の値 (value) が1つのセル (cell) をなす\n\n上の表は，地点，時間，天気，気温の4つの変数があり1つの列をつくっています(ルール1)。 大阪12時の天気は雨，気温は12℃といったように1つの行が1つの観測を表しています(ルール2)。 このデータには種類の異なる観測はない(ルール3)。 また，各セルには1つの値が入っています(ルール4)。 よって，これが整然データとなります。\n上のロング型の天気データを使って，ロングからワイド，ワイドからロングの操作を学びましょう。\nまずデータを作ります。\n\ndf_weather &lt;- data.frame(\n    place = c(\"札幌\",\"札幌\",\"札幌\",\"大阪\",\"大阪\",\"大阪\",\"福岡\",\"福岡\",\"福岡\"), # 各地を3個ずつ\n    time = rep(c(\"6時\", \"12時\", \"18時\"),3),\n    temp = c(12,15,13,20,24,22,23,25,25)\n)\nprint(df_weather)\n\n  place time temp\n1  札幌  6時   12\n2  札幌 12時   15\n3  札幌 18時   13\n4  大阪  6時   20\n5  大阪 12時   24\n6  大阪 18時   22\n7  福岡  6時   23\n8  福岡 12時   25\n9  福岡 18時   25\n\n\nこれはロング型の整然データとなります。\n\n\nロングからワイド pivot_wider\nRで使うならこのままでよいのですが，あえてこれをワイド型に変えてみましょう。\n教科書で使用されているspread()は「根本的に設計ミスってた」と公式で発表されているので，R神が作ったpivot_wider()を使います。widerという名前の通り，ワイド型に変換する関数です。\npivot_wider()の引数は，names_fromとvalues_fromです。names_fromは，ワイド型に変換するときに，どの変数を列にするかを指定します。values_fromは，ワイド型に変換するときに，どの変数の値を使うかを指定します。\n以下のコードでは，time変数の値を列に，temp変数の値を値にして，df_wideという変数に代入しています。\n\ndf_wide &lt;- df_weather %&gt;%\n    pivot_wider(names_from = time, values_from = temp)\nprint(df_wide)\n\n# A tibble: 3 × 4\n  place `6時` `12時` `18時`\n  &lt;chr&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n1 札幌     12     15     13\n2 大阪     20     24     22\n3 福岡     23     25     25\n\n\nこれでワイド型に変換できました。\n\n\nワイドからロング pivot_longer\n次に，このワイド型のデータをロング型に変換してみます。 教科書では，tidyrのgather()を使っていますが，これもwider()と同じ問題を持っているので，R神によるpivot_longer()を使います。\npivot_longer()の引数は，colsとnames_toとvalues_toです。\n\ncolsは，ロング型に変換するときに，どの変数を行にするかを指定\nnames_toは，ロング型に変換するときに，どの変数の値を使うかを指定\nvalues_toは，ロング型に変換するときに，どの変数の値を使うかを指定\n\n以下のコードでは，6時，12時，18時の3つの変数を行に，timeという変数の値を列に，tempという変数の値を値にして，df_longという変数に代入しています。\n\ndf_long &lt;- df_wide %&gt;%\n    pivot_longer(\n        cols = c(\"6時\", \"12時\", \"18時\"), # 縦にする変数\n        names_to = \"time\", # 縦にした変数名\n        values_to = \"temp\") # 値\nprint(df_long)\n\n# A tibble: 9 × 3\n  place time   temp\n  &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt;\n1 札幌  6時      12\n2 札幌  12時     15\n3 札幌  18時     13\n4 大阪  6時      20\n5 大阪  12時     24\n6 大阪  18時     22\n7 福岡  6時      23\n8 福岡  12時     25\n9 福岡  18時     25\n\n\n元のロング型に戻りました。\n\n\n5.3.4 データの結合\n別々のデータを結合させて使いたいことはよくあります。 例えば，次のようなデータを結合させる場合を考えてみましょう。\n\n表A\n\n\n\nname\nterm\nsale\n\n\n\n\nトヨタ\n2020\n1000\n\n\nトヨタ\n2021\n900\n\n\nトヨタ\n2022\n1400\n\n\nホンダ\n2020\n800\n\n\nホンダ\n2021\n700\n\n\nホンダ\n2022\n900\n\n\n\n\ndf_A &lt;- data.frame(\n    name = c(\"トヨタ\", \"トヨタ\", \"トヨタ\", \"ホンダ\", \"ホンダ\", \"ホンダ\"),\n    term = c(2020, 2021, 2022, 2020, 2021, 2022),\n    sale = c(1000, 900, 1400, 800, 700, 900)\n)\n\n\n\n表B\n\n\n\nname\nterm\nsale\n\n\n\n\n日産\n2020\n400\n\n\n日産\n2021\n500\n\n\n日産\n2022\n900\n\n\nマツダ\n2020\n300\n\n\nマツダ\n2021\n400\n\n\nマツダ\n2022\n200\n\n\n\n\ndf_B &lt;- data.frame(\n    name = c(\"日産\", \"日産\", \"日産\", \"マツダ\", \"マツダ\", \"マツダ\"),\n    term = c(2020, 2021, 2022, 2020, 2021, 2022),\n    sale = c(400, 500, 900, 300, 400, 200)\n)\n\n\n\n表C\n\n\n\nname\nterm\nnetincome\n\n\n\n\nトヨタ\n2020\n100\n\n\nトヨタ\n2021\n90\n\n\nトヨタ\n2022\n150\n\n\nホンダ\n2020\n140\n\n\nホンダ\n2021\n100\n\n\nホンダ\n2022\n90\n\n\nスバル\n2020\n30\n\n\nスバル\n2021\n35\n\n\nスバル\n2022\n50\n\n\n\n\ndf_C &lt;- data.frame(\n    name = c(\"トヨタ\", \"トヨタ\", \"トヨタ\", \"ホンダ\", \"ホンダ\", \"ホンダ\", \"スバル\", \"スバル\", \"スバル\"),\n    term = c(2020, 2021, 2022, 2020, 2021, 2022, 2020, 2021, 2022),\n    netincome = c(100, 90, 150, 140, 100, 90, 30, 35, 50)\n)\n\nこの3つのデータを結合させる場合を考えます。 まず表Aと表Bは同じ変数をもつデータなので，これらを結合させるには，縦につなげる必要があります。 このような結合を連結といいます。 縦結合は，dplyrパッケージのbind_rows()関数を使います。\n\ndf_AB &lt;- bind_rows(df_A, df_B)\nprint(df_AB)\n\n     name term sale\n1  トヨタ 2020 1000\n2  トヨタ 2021  900\n3  トヨタ 2022 1400\n4  ホンダ 2020  800\n5  ホンダ 2021  700\n6  ホンダ 2022  900\n7    日産 2020  400\n8    日産 2021  500\n9    日産 2022  900\n10 マツダ 2020  300\n11 マツダ 2021  400\n12 マツダ 2022  200\n\n\n縦に結合できたので，トヨタ，ホンダ，日産，マツダのデータが入ったデータベースdf_ABができました。\n次に，このdf_ABとdf_Cを結合させます。 df_Cはnetincomeというdf_ABにはない変数があり，異なる変数をもつデータ同士の結合となります。 これらを結合させるには，横につなげる必要があります。 このような結合を結合といいます。\n結合には，\n\n内部結合(inner join)\n外部結合(outer join)\n\nがあり，外部結合には，\n\n完全結合(full join)\n左結合(left join)\n右結合(right join)\n\nがあります。\n内部結合は両方のデータベースに存在する観測値のみを保持するため，多くのデータが欠落することになりますが，外部結合は、少なくとも1つのテーブルに存在する観測値を保持するので，データが欠落することはありません。 3つの外部結合の特徴は次の通りです。\n\n完全結合は、xとyのすべてのオブザベーションを保持します。\n左結合は、xのすべてのオブザベーションを保持します。\n右結合は、yのすべてのオブザベーションを保持します。\n\n図でみるとつぎようになります。\n\n\n\n外部結合の例\n\n\n内部結合と3つの外部結合をベン図で表すとこうなります。\n\n\n\n外部結合のベン図\n\n\n最もよく使われる結合は左結合です。 元データに他のデータを結合する場合，元データに含まれるデータのみ保持したい場合が多いので，追加データを調べるときはいつもこれを使います。 左結合はデフォルトの結合であるべきで、他の結合を選択する強い理由がない限り、これを使用します。\nでは，df_ABとdf_Cを左結合してみましょう。 結合する際にキーとなる変数を指定する必要があります。 ここではnameとtermの2つの変数をキーとして指定します。 こうすることで，nameとtermが一致する観測値を結合します。\n\ndf_left &lt;- df_AB %&gt;%\n    left_join(df_C, by = c(\"name\", \"term\"))\nprint(df_left)\n\n     name term sale netincome\n1  トヨタ 2020 1000       100\n2  トヨタ 2021  900        90\n3  トヨタ 2022 1400       150\n4  ホンダ 2020  800       140\n5  ホンダ 2021  700       100\n6  ホンダ 2022  900        90\n7    日産 2020  400        NA\n8    日産 2021  500        NA\n9    日産 2022  900        NA\n10 マツダ 2020  300        NA\n11 マツダ 2021  400        NA\n12 マツダ 2022  200        NA\n\n\ndf_ABにはトヨタ，ホンダ，日産，マツダのデータがありますが，df_Cには日産とマツダのデータがなく，スバルのデータがあります。 そのため左結合すると，日産とマツダのnetincomeにはNAが入り，スバルは欠落します。\ndf_ABとdf_Cを右結合してみましょう。\n\ndf_right &lt;- df_AB %&gt;%\n    right_join(df_C, by = c(\"name\", \"term\"))\nprint(df_right)\n\n    name term sale netincome\n1 トヨタ 2020 1000       100\n2 トヨタ 2021  900        90\n3 トヨタ 2022 1400       150\n4 ホンダ 2020  800       140\n5 ホンダ 2021  700       100\n6 ホンダ 2022  900        90\n7 スバル 2020   NA        30\n8 スバル 2021   NA        35\n9 スバル 2022   NA        50\n\n\ndf_Cには日産とマツダのデータがなく，トヨタとホンダとスバルのデータがあります。 そのため右結合すると日産とマツダのデータが欠落し，df_Cに含まれていたトヨタ，ホンダ，スバルのデータが残ります。 しかしスバルのsaleにはNAが入ります。\n最後に，df_ABとdf_Cを完全結合してみましょう。\n\ndf_full &lt;- df_AB %&gt;%\n    full_join(df_C, by = c(\"name\", \"term\"))\nprint(df_full)\n\n     name term sale netincome\n1  トヨタ 2020 1000       100\n2  トヨタ 2021  900        90\n3  トヨタ 2022 1400       150\n4  ホンダ 2020  800       140\n5  ホンダ 2021  700       100\n6  ホンダ 2022  900        90\n7    日産 2020  400        NA\n8    日産 2021  500        NA\n9    日産 2022  900        NA\n10 マツダ 2020  300        NA\n11 マツダ 2021  400        NA\n12 マツダ 2022  200        NA\n13 スバル 2020   NA        30\n14 スバル 2021   NA        35\n15 スバル 2022   NA        50\n\n\ndf_ABにはトヨタ，ホンダ，日産，マツダのデータがありますが，df_Cにはトヨタ，ホンダ，スバルのデータがあるため， 完全結合したdf_fullにはすべての企業のデータが入ります。 しかし，日産とマツダのnetincomeにはNAが入り，スバルのsaleにもNAが入ります。\nこのように，結合するデータによって，結合したデータに含まれるデータが変わるので，自分が望む結合後のデータの形を考えて，どの結合を使うかを選ぶ必要があります。\nついでに内部結合もやってみましょう。\n\ndf_inner &lt;- df_AB %&gt;%\n    inner_join(df_C, by = c(\"name\", \"term\"))\nprint(df_inner)\n\n    name term sale netincome\n1 トヨタ 2020 1000       100\n2 トヨタ 2021  900        90\n3 トヨタ 2022 1400       150\n4 ホンダ 2020  800       140\n5 ホンダ 2021  700       100\n6 ホンダ 2022  900        90\n\n\n予想どおり，両方のデータに含まれているトヨタとホンダだけが残り，片方のデータにしか含まれていない日産，マツダ，スバルのデータは欠落してしまいました。 このように内部結合は，両方のデータに存在する観測値のみを保持するため，多くのデータが欠落することになり，利用する機会があまりないです。"
  },
  {
    "objectID": "Empoli_Chap04.html#rとrstudio",
    "href": "Empoli_Chap04.html#rとrstudio",
    "title": "4  Rの使い方",
    "section": "4.1 RとRstudio",
    "text": "4.1 RとRstudio"
  },
  {
    "objectID": "Empoli_Chap04.html#rの基本操作",
    "href": "Empoli_Chap04.html#rの基本操作",
    "title": "4  Rの使い方",
    "section": "4.2 Rの基本操作",
    "text": "4.2 Rの基本操作"
  },
  {
    "objectID": "Empoli_Chap04.html#パッケージ",
    "href": "Empoli_Chap04.html#パッケージ",
    "title": "4  Rの使い方",
    "section": "4.3 パッケージ",
    "text": "4.3 パッケージ"
  },
  {
    "objectID": "Empoli_Chap04.html#visual-studio-codeの使い方",
    "href": "Empoli_Chap04.html#visual-studio-codeの使い方",
    "title": "4  Rの使い方",
    "section": "4.4 Visual Studio Codeの使い方",
    "text": "4.4 Visual Studio Codeの使い方\n\n4.4.1 フォルダを開く\n\n\n4.4.2 Rスクリプトの書き方\n\n\n4.4.3 Githubとの連携\n\n\n4.4.4 GitHub Copilotを使う"
  },
  {
    "objectID": "Empoli_Chap04.html#まとめ",
    "href": "Empoli_Chap04.html#まとめ",
    "title": "4  Rの使い方",
    "section": "4.5 まとめ",
    "text": "4.5 まとめ"
  },
  {
    "objectID": "Empoli_Chap01.html#footnotes",
    "href": "Empoli_Chap01.html#footnotes",
    "title": "1  計量会計学とは",
    "section": "",
    "text": "ちなみに(広義の)実証会計学(positive accounting thoery)は、事実解明的研究として、会計実務を説明し予想するための理論の構築を目指す学問を指す会計研究を意味します。いまはどうでも良いことです。\n他にも、数理モデルを用いた会計研究を分析的会計研究(analytical accounting research)、実験経済を用いた会計研究を(experimental accounting research)、行動科学の理論を用いた会計研究を(behavioral accounting research)といい、これらも広くは広義の実証会計となります。\nその他にも、簿記を研究対象とした簿記論、会計計算の仕組みを研究する計算構造研究、会計の歴史を研究する会計史など様々な研究分野があります。↩︎"
  },
  {
    "objectID": "Empoli_Chap06.html#変数の種類と記述統計",
    "href": "Empoli_Chap06.html#変数の種類と記述統計",
    "title": "6  記述統計とデータの可視化・視覚化",
    "section": "6.1 変数の種類と記述統計",
    "text": "6.1 変数の種類と記述統計\nデータには「カテゴリ変数」(category variable)と「量的変数」(quantitative variable)あるいは「連続変数」(continuous variable)があり，それぞれに対して適切なグラフの種類があります。\n\n6.1.1 カテゴリー変数と量的変数\nカテゴリー変数(category variable)とは、観測値が属するカテゴリーを表す変数です。 たとえば、日経産業中分類の「水産」は35、鉱業は37，建設は41ですが、これらの数値は足したり引いたりすることに意味はありません。\n量的変数(quantitative variable)とは、観測値が数値で表される変数です。 たとえば、売上高や株価は金額で表されるため、足したり引いたり、平均や分散を計算することに意味があります。\nしたがって、手元にあるデータベースの各変数がカテゴリー変数か量的変数かを把握することは極めて重要です。 Rでは自動で両者を区別したりはしてくれないので、データを読み込んだ後に変数の種類を確認し、自分で指定します。\n\n\n練習用データの読み込み\nここでは、教科書とは違う、企業の財務データを使いながら、データの可視化を学びます。\n\ndf &lt;- read_csv(\"data/RD_2022.csv\")\nglimpse(df)\n\nRows: 57,823\nColumns: 23\n$ 会社コード                     &lt;chr&gt; \"0000001\", \"0000001\", \"0000001\", \"00000…\n$ 企業名                         &lt;chr&gt; \"極洋\", \"極洋\", \"極洋\", \"極洋\", \"極洋\",…\n$ 決算期                         &lt;chr&gt; \"1999/03\", \"2000/03\", \"2001/03\", \"2002/…\n$ 決算種別                       &lt;dbl&gt; 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,…\n$ 連結基準                       &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, …\n$ 決算月数                       &lt;dbl&gt; 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,…\n$ 上場コード                     &lt;dbl&gt; 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,…\n$ 日経業種コード                 &lt;dbl&gt; 235341, 235341, 235341, 235341, 235341,…\n$ 現金預金                       &lt;dbl&gt; 6307, 4951, 3818, 4185, 4015, 3456, 277…\n$ 資産合計                       &lt;dbl&gt; 62109, 60885, 60599, 57069, 55373, 5856…\n$ 資本金                         &lt;dbl&gt; 5664, 5664, 5664, 5664, 5664, 5664, 566…\n$ 資本剰余金                     &lt;dbl&gt; NA, NA, NA, NA, 742, 742, 742, 743, 749…\n$ 利益剰余金                     &lt;dbl&gt; 2739, 4238, 4812, 5485, 6254, 6378, 727…\n$ 自己株式                       &lt;dbl&gt; NA, NA, -79, -154, -387, -464, -368, -2…\n$ 売上高                         &lt;dbl&gt; 171944, 171031, 166644, 158006, 162773,…\n$ 経常利益                       &lt;dbl&gt; 1600, 2299, 1947, 2333, 3314, 2895, 335…\n$ 法人税等                       &lt;dbl&gt; 620, 606, 908, 856, 1234, 1302, 1422, 1…\n$ 法人税等調整額                 &lt;dbl&gt; NA, -178, -114, 44, -272, -234, 136, -3…\n$ 親会社株主に帰属する当期純利益 &lt;dbl&gt; -251, 327, 927, 1026, 1122, 1248, 1388,…\n$ 研究開発費IFRS                 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ 研究開発費                     &lt;dbl&gt; 210, 201, 190, 179, 197, 212, 201, 193,…\n$ `開発費・試験研究費`           &lt;dbl&gt; 210, 105, 119, 153, 176, 156, 122, 148,…\n$ 現金及び現金同等物の期末残高   &lt;dbl&gt; NA, 4865, 3729, 4097, 3923, 3359, 2725,…\n\n\n23個の変数があり、データの個数は57,823となっています。 以下ではこのデータを使って、データの可視化を学びます。\n\n\n6.1.2 基本的な統計量の確認\nはじめにsummary()で基本的な統計量を確認します。\n\nsummary(df)\n\n  会社コード           企業名             決算期             決算種別 \n Length:57823       Length:57823       Length:57823       Min.   :10  \n Class :character   Class :character   Class :character   1st Qu.:10  \n Mode  :character   Mode  :character   Mode  :character   Median :10  \n                                                          Mean   :10  \n                                                          3rd Qu.:10  \n                                                          Max.   :10  \n                                                                      \n    連結基準        決算月数       上場コード    日経業種コード  \n Min.   :1.000   Min.   : 1.00   Min.   :11.00   Min.   :101001  \n 1st Qu.:1.000   1st Qu.:12.00   1st Qu.:11.00   1st Qu.:121204  \n Median :1.000   Median :12.00   Median :11.00   Median :241403  \n Mean   :1.062   Mean   :11.98   Mean   :11.46   Mean   :190751  \n 3rd Qu.:1.000   3rd Qu.:12.00   3rd Qu.:12.00   3rd Qu.:257561  \n Max.   :3.000   Max.   :17.00   Max.   :13.00   Max.   :271704  \n                                                                 \n    現金預金           資産合計             資本金          資本剰余金     \n Min.   :       4   Min.   :       70   Min.   :      1   Min.   :-161917  \n 1st Qu.:    2023   1st Qu.:    14062   1st Qu.:   1198   1st Qu.:    965  \n Median :    5370   Median :    39028   Median :   3363   Median :   2995  \n Mean   :   38172   Mean   :   363536   Mean   :  16481   Mean   :  20259  \n 3rd Qu.:   16467   3rd Qu.:   125705   3rd Qu.:  10090   3rd Qu.:   9927  \n Max.   :68502665   Max.   :303846980   Max.   :3500000   Max.   :4503856  \n NA's   :193        NA's   :44          NA's   :198       NA's   :7714     \n   利益剰余金          自己株式            売上高            経常利益      \n Min.   : -972773   Min.   :-3306037   Min.   :       1   Min.   :-869562  \n 1st Qu.:    2250   1st Qu.:   -1368   1st Qu.:   13366   1st Qu.:    425  \n Median :    9163   Median :    -279   Median :   38209   Median :   1626  \n Mean   :   75680   Mean   :   -5144   Mean   :  237440   Mean   :  14070  \n 3rd Qu.:   34436   3rd Qu.:     -39   3rd Qu.:  127091   3rd Qu.:   6126  \n Max.   :26453126   Max.   :      -1   Max.   :31379507   Max.   :5670456  \n NA's   :299        NA's   :10800      NA's   :27         NA's   :21       \n    法人税等       法人税等調整額       親会社株主に帰属する当期純利益\n Min.   : -21709   Min.   :-1139009.0   Min.   :-1708029              \n 1st Qu.:    159   1st Qu.:    -134.5   1st Qu.:     163              \n Median :    586   Median :      -7.0   Median :     823              \n Mean   :   4827   Mean   :    -114.7   Mean   :    7707              \n 3rd Qu.:   2170   3rd Qu.:      91.0   3rd Qu.:    3372              \n Max.   :1190782   Max.   : 1097414.0   Max.   : 4987962              \n NA's   :391       NA's   :3736         NA's   :29                    \n 研究開発費IFRS     研究開発費      開発費・試験研究費\n Min.   :    48   Min.   :      1   Min.   :     1    \n 1st Qu.:  2440   1st Qu.:    131   1st Qu.:   169    \n Median : 24628   Median :    547   Median :   651    \n Mean   : 91248   Mean   :   8441   Mean   :  7528    \n 3rd Qu.:108096   3rd Qu.:   2330   3rd Qu.:  2710    \n Max.   :806905   Max.   :1124262   Max.   :662610    \n NA's   :57583    NA's   :21525     NA's   :38296     \n 現金及び現金同等物の期末残高\n Min.   :    -292            \n 1st Qu.:    1913            \n Median :    5328            \n Mean   :   39185            \n 3rd Qu.:   16954            \n Max.   :68419223            \n NA's   :1591                \n\n\n文字列となっている変数以外の量的変数については、最小値、第1四分位、中央値、平均値、第3四分位、最大値、欠損値の数、といった項目が計算されています。 数値データのうち、カテゴリー変数の統計量については意味が無いです。\n23個の変数の型を確認すると、大部分の財務データは数値&lt;dbl&gt;ですが、\n\n会社コード\n企業名\n決算期\n\nの3つは文字列&lt;chr&gt;となっています。 また、数値となっているけれど、実際はカテゴリー変数であるものとして、\n\n決算種別 : 10 = 本決算\n連結基準 : 1 = 日本基準, 2 = 米国基準, 3 = IFRS, 0 = 単独\n上場コード : 11 = 東証1部, 12 = 東証2部, 13 = 東証マザーズ,\n日経業種コード : 後で説明あり\n\nがあります。 文字列となっている変数はともかく、数値となっているカテゴリー変数は平均などを計算しても意味は無いので、数値ではなくファクター型とする必要があります。\nとりあえず、数値データのうち、カテゴリー変数ではないものについて、統計量を計算してみます。 主要な統計量を返す関数には以下のものがあります。\n\nmean() : 算術平均を計算する\nmedian() : 中央値を計算する\nsd() : (不偏)標準偏差を計算する\nvar() : (不偏)分散を計算する\nmin() : 最小値を計算する\nmax() : 最大値を計算する\n\nでは、売上高の平均を計算してみましょう。 データdfの売上高にアクセスするには、df$売上高のように、$を使って変数名を指定します。\n\nmean(df$売上高)\n\n[1] NA\n\n\nNAが帰ってきました。 実は、このmean()関数は、引数となるベクトル変数の中にNAがあると、自動的にNAを返します。 NAは欠損値を表すもので、データベースにおいて、値が存在しないことを表します。 このような場合、NAを除外して平均を計算する必要があるので、na.rm = TRUEという引数を追加します。\n\nmean(df$売上高, na.rm = TRUE)\n\n[1] 237440.1\n\n\nこれで、売上高の平均が2.3744011^{5}となりました。\n同じように、\n\nmedian(df$売上高, na.rm = TRUE)\n\n[1] 38209\n\nsd(df$売上高, na.rm = TRUE)\n\n[1] 938244.4\n\n\nとすることで、中央値と標準偏差が求められます。\n\n\n6.1.3 カテゴリ変数の内容確認\nカテゴリー変数について見ていきましょう。 ここでは日経業種コードを例にとります。 日経業種コードは6ケタの数字ですが、最初の1ケタが大分類、次の2ケタ目が中分類、最後の3ケタ目が小分類を表します。つまり1 + 32 + 344のような構造になっています。 実証会計研究では、産業中分類をよく使うので、ここでは中分類を抽出してみましょう。 またしてもsubstr()関数を使って、2〜3ケタ目を抽出し、中分類という変数に格納します。 ついでに，決算期のデータがYYYY/MMという形式になっているので，最初の4桁を抽出して，年度という変数に格納します。\n\ndf &lt;- df %&gt;%\n  mutate(\n    中分類 = substr(日経業種コード, 2, 3),\n    年度 = substr(決算期, 1, 4)\n    )\n\nこの中分類の内容を確認するには、table()関数を使います。\n\ntable(df$中分類)\n\n\n   01    03    05    07    09    11    13    15    17    19    21    23    25 \n 2215   934   432  3915   947   178   459  1066   906  2174  4338  5016    96 \n   27    29    31    33    35    37    41    43    45    52    53    55    57 \n 1651   253  1035  1936   203   131  2715  5926  3501   832  1674   670   640 \n   59    61    63    65    67    69    71 \n  261    96   746   625   285   214 11753 \n\n\nこのように、中分類ごとの企業数が計算されました。 このカテゴリー変数の型をclass()関数で確認します。\n\nclass(df$中分類)\n\n[1] \"character\"\n\n\ncharacterつまり文字列となっています。これをファクター型に変えて、カテゴリー変数であることを明示します。as.factor()関数を使うと、ファクター型に変換できます。\n\ndf &lt;- df %&gt;%\n  mutate(中分類 = as.factor(中分類))\n\nこれで、中分類がカテゴリー変数となりました。 しかし、このままでは、中分類の内容がわかりません。 そこで、factor()関数を使って、カテゴリー変数の内容を指定します。 ついでに，上場コードや連結基準もファクター型に変換しておきます。\n\ndf &lt;- df %&gt;%\n  mutate(\n    中分類 = factor(\n      中分類,\n      levels = c(35,37,41,01,03,05,07,09,11,13,15,17,19,21,23,25,27,29,31,33,43,45,47,49,51,52,53,55,57,59,61,63,65,67,69,71),\n      labels = c(\"水産\",\"鉱業\",\"建設\",\"食品\",\"繊維\",\"パルプ・紙\",\"化学工業\",\"医薬品\",\"石油\",\"ゴム\",\"窯業\",\"鉄鉱業\",\"非金属及び金属製品\",\"機械\",\"電気機器\",\"造船\",\"自動車・自動車部品\",\"その他輸送用機器\",\"精密機器\",\"その他製造業\",\"商社\",\"小売業\",\"銀行\",\"証券\",\"保険\",\"その他金融業\",\"不動産\",\"鉄道・バス\",\"陸運\",\"海運\",\"空輸\",\"倉庫・運輸関連\",\"通信\",\"電力\",\"ガス\",\"サービス業\")),\n    上場コード = factor(\n      上場コード,\n      levels = c(11,12,13),\n      labels = c(\"1部\",\"2部\",\"マザーズ\")),\n    連結基準 = factor(\n      連結基準,\n      levels = c(1,2,3,0),\n      labels = c(\"日本基準\",\"米国基準\",\"IFRS\",\"単独\"))\n      )\n\n\nsummary(df)\n\n  会社コード           企業名             決算期             決算種別 \n Length:57823       Length:57823       Length:57823       Min.   :10  \n Class :character   Class :character   Class :character   1st Qu.:10  \n Mode  :character   Mode  :character   Mode  :character   Median :10  \n                                                          Mean   :10  \n                                                          3rd Qu.:10  \n                                                          Max.   :10  \n                                                                      \n     連結基準        決算月数        上場コード    日経業種コード  \n 日本基準:55727   Min.   : 1.00   1部     :33171   Min.   :101001  \n 米国基準:  581   1st Qu.:12.00   2部     :22529   1st Qu.:121204  \n IFRS    : 1515   Median :12.00   マザーズ: 2123   Median :241403  \n 単独    :    0   Mean   :11.98                    Mean   :190751  \n                  3rd Qu.:12.00                    3rd Qu.:257561  \n                  Max.   :17.00                    Max.   :271704  \n                                                                   \n    現金預金           資産合計             資本金          資本剰余金     \n Min.   :       4   Min.   :       70   Min.   :      1   Min.   :-161917  \n 1st Qu.:    2023   1st Qu.:    14062   1st Qu.:   1198   1st Qu.:    965  \n Median :    5370   Median :    39028   Median :   3363   Median :   2995  \n Mean   :   38172   Mean   :   363536   Mean   :  16481   Mean   :  20259  \n 3rd Qu.:   16467   3rd Qu.:   125705   3rd Qu.:  10090   3rd Qu.:   9927  \n Max.   :68502665   Max.   :303846980   Max.   :3500000   Max.   :4503856  \n NA's   :193        NA's   :44          NA's   :198       NA's   :7714     \n   利益剰余金          自己株式            売上高            経常利益      \n Min.   : -972773   Min.   :-3306037   Min.   :       1   Min.   :-869562  \n 1st Qu.:    2250   1st Qu.:   -1368   1st Qu.:   13366   1st Qu.:    425  \n Median :    9163   Median :    -279   Median :   38209   Median :   1626  \n Mean   :   75680   Mean   :   -5144   Mean   :  237440   Mean   :  14070  \n 3rd Qu.:   34436   3rd Qu.:     -39   3rd Qu.:  127091   3rd Qu.:   6126  \n Max.   :26453126   Max.   :      -1   Max.   :31379507   Max.   :5670456  \n NA's   :299        NA's   :10800      NA's   :27         NA's   :21       \n    法人税等       法人税等調整額       親会社株主に帰属する当期純利益\n Min.   : -21709   Min.   :-1139009.0   Min.   :-1708029              \n 1st Qu.:    159   1st Qu.:    -134.5   1st Qu.:     163              \n Median :    586   Median :      -7.0   Median :     823              \n Mean   :   4827   Mean   :    -114.7   Mean   :    7707              \n 3rd Qu.:   2170   3rd Qu.:      91.0   3rd Qu.:    3372              \n Max.   :1190782   Max.   : 1097414.0   Max.   : 4987962              \n NA's   :391       NA's   :3736         NA's   :29                    \n 研究開発費IFRS     研究開発費      開発費・試験研究費\n Min.   :    48   Min.   :      1   Min.   :     1    \n 1st Qu.:  2440   1st Qu.:    131   1st Qu.:   169    \n Median : 24628   Median :    547   Median :   651    \n Mean   : 91248   Mean   :   8441   Mean   :  7528    \n 3rd Qu.:108096   3rd Qu.:   2330   3rd Qu.:  2710    \n Max.   :806905   Max.   :1124262   Max.   :662610    \n NA's   :57583    NA's   :21525     NA's   :38296     \n 現金及び現金同等物の期末残高        中分類          年度          \n Min.   :    -292             サービス業:11753   Length:57823      \n 1st Qu.:    1913             商社      : 5926   Class :character  \n Median :    5328             電気機器  : 5016   Mode  :character  \n Mean   :   39185             機械      : 4338                     \n 3rd Qu.:   16954             小売業    : 3501                     \n Max.   :68419223             (Other)   :18846                     \n NA's   :1591                 NA's      : 8443                     \n\n\n\n\n6.1.4 2つのカテゴリー変数の関係を確かめる\n2つの変数から表を作成する方法について学びます。 典型的な表として，2変数のクロス集計表があります。 例えば，連結基準，つまり企業が採用している会計基準の種類と，上場コード，つまり企業が上場している市場の種類，の2変数について，それぞれのカテゴリーごとの企業数を計算することができます。\n\ntable(df$連結基準, df$上場コード)\n\n          \n             1部   2部 マザーズ\n  日本基準 31290 22432     2005\n  米国基準   580     0        1\n  IFRS      1301    97      117\n  単独         0     0        0\n\n\n圧倒的に，日本基準で上場している企業が多いことがわかります。 2020年度のデータだけを抽出して，同じようにクロス集計表を作成してみましょう。\n\ndf %&gt;%\n  filter(年度 == 2020) %&gt;%\n  with(table(連結基準, 上場コード))\n\n          上場コード\n連結基準  1部  2部 マザーズ\n  日本基準 1474 1177      259\n  米国基準   11    0        0\n  IFRS      194   15       22\n  単独        0    0        0\n\n\n東証1部に上場している企業に注目すると，日本基準採用企業が1474社，米国基準採用企業が11社，IFRS採用企業が194社となっていることがわかりました。\nこのように，table()関数の引数として2つのカテゴリー変数を指定すると，そこから2 \\times 2のグループに属する企業数を計算し，表を作成してくれます。\nここで急に登場したwith()関数ですが，with()関数は主として次の2つの引数をとります。\n\nデータ\n式\n\n例えば，先の表を作る場合を考えてみましょう。 普通に書くと\n\ntable(df$連結基準, df$上場コード)\n\nとかきましたが，何度もdf$を書くことが面倒なので，with()関数を使って\n\nwith(df, table(連結基準, 上場コード))\n\nと，第1引数にdfを指定すれば，第2引数の式の中でdf$を書く必要がなくなります。したがって，パイプ演算子を使って，\n\ndf %&gt;% with(table(連結基準, 上場コード))\n\nと処理をつなげることができます。 便利ですね。\n\n\n6.1.5 カテゴリー別に量的変数の値を調べる\n次は，量的変数をカテゴリーごとに分析したいときがあります。 たとえば，産業別や年度別に売上高の平均値を知りたい，ということが何度もあります。 任意のグループごとに処理を繰り返したいときは，dplyrパッケージのgroup_by()関数を使います。 group_by()関数は，第1引数にグループ化したい変数を指定します。\nそしてgroup_by()関数と同時に使うことで，グループごとの統計量を計算するために便利なのがdplyrパッケージのsummarize()関数です。 summarize()関数は，次のような引数をとり，各種統計量を計算してくれます。\n\nmean = : 平均\nmedian = : 中央値\nsd = : 標準偏差\nvar = : 分散\nn() : グループごとの観測値の個数\n\n例えば，上場場所ごとに売上高の平均値を計算するには，次のようにします。\n\ndf %&gt;%\n  group_by(上場コード) %&gt;%\n  summarize(\n    企業数 = n(),\n    平均売上高 = mean(売上高, na.rm = TRUE) # 平均\n    ) %&gt;%\n  knitr::kable(booktabs = TRUE)\n\n\n\n\n上場コード\n企業数\n平均売上高\n\n\n\n\n1部\n33171\n393156.220\n\n\n2部\n22529\n29884.533\n\n\nマザーズ\n2123\n5459.012\n\n\n\n\n\n結果を見れば分かるとおり，group_by()で上場場所ごとにグループ化し，summarize()で企業数と平均売上高を計算しているので，上場場所，企業数，平均売上高の3変数が3つの観測値をもつ3 \\times 3の表が作成されています。 group_by()とsummarize()を組み合わせると，結果としてグループ数に応じた統計量を計算した結果となり，元のデータよりも小さなデータフレームとなって返ってきます。\n次のグラフ作成のためのデータを作成するため，年度別ごとに，ROEの平均値を計算し，その結果をdf_yearという変数に代入します。 ROEは，ある年度の親会社に帰属する当期純利益を期首株主資本で割った値です。 株主資本は，資本金と資本剰余金，利益剰余金，自己株式の合計で計算します。\n\ndf &lt;- df %&gt;%\n  replace_na(list(資本剰余金 = 0, 利益剰余金 = 0, 自己株式 = 0)) %&gt;%\n  group_by(企業名) %&gt;% # 会社ごとに\n  mutate(\n    株主資本 = 資本金 + 資本剰余金 + 利益剰余金 + 自己株式, # 株主資本を計算\n    ) %&gt;%\n    filter(株主資本 &gt;0 ) %&gt;% # 株主資本がマイナスの企業を除外\n  mutate(\n    ROE = 親会社株主に帰属する当期純利益 / lag(株主資本) # ROEを計算\n    )\n\n\ndf_year &lt;- df %&gt;%\n  group_by(年度) %&gt;%\n  summarize(\n    平均ROE = mean(ROE, na.rm = TRUE)\n    ) %&gt;%\n    ungroup()\n\nこれで，年度ごと，上場場所ごとに，平均ROEを計算したデータフレームdf_yearができました。\nここで注意しなければならない点として，group_by(企業名)とした上で，lag()関数を使っている点です。 lag()関数は，引数として指定した変数の値の1つ前の値に変換します。 したがって，group_by()を使わないと次のような結果になります。\n\n\n\n\n\n企業名\n年度\n株主資本\nROE\n\n\n\n\n極洋\n2020\n32396\n0.0649844\n\n\n極洋\n2021\n35300\n0.1184714\n\n\n極洋\n2022\n39072\n0.1312748\n\n\n日本水産\n1999\n58734\nNA\n\n\n日本水産\n2000\n67055\n0.0862192\n\n\n日本水産\n2001\n64842\n0.0460070\n\n\n\n\n\nここで問題になっているのが，日本水産の1999年のROEが計算されている点である。 ROEは分子に親会社株主に帰属する当期純利益，分母に期首株主資本，つまりは前期末の株主資本を使います。 したがって，1999年のROEを計算するためには，1998年の株主資本を使う必要がありますが，データは1999年からしか存在しないので欠損値にならないといけないのに，計算されてしまっています。 つまり，一つ上の極洋の2022年の株主資本のデータを使っているのです。 そこで，group_by()により企業ごとにグループ化して，lag()関数を使って，一つ前の観測値を使うようにし，1999年のROEは欠損値になるようにします。\n\n\n\n\n\n企業名\n年度\n株主資本\nROE\n\n\n\n\n極洋\n2020\n32396\n0.0649844\n\n\n極洋\n2021\n35300\n0.1184714\n\n\n極洋\n2022\n39072\n0.1312748\n\n\n日本水産\n1999\n58734\nNA\n\n\n日本水産\n2000\n67055\n0.0862192\n\n\n日本水産\n2001\n64842\n0.0460070"
  },
  {
    "objectID": "Empoli_Chap05.html#データの保存",
    "href": "Empoli_Chap05.html#データの保存",
    "title": "5  Rによるデータ操作",
    "section": "5.4 データの保存",
    "text": "5.4 データの保存\n前処理が終わったデータは，ファイルとして保存しておくとよいでしょう。 たとえば，df_leftをdf_left.csvというファイル名で保存するには，readrパッケージのwrite_csv()関数を使います。\nwrite_csv()関数の第1引数は保存したいオブジェクト(ここではdf_left)で，あとの主要な引数は，\n\nfile\nna = \"NA\"\nappend = FALSE\n\nとなります。 fileは保存するファイル名を指定します。 naは欠損値をどうするかを指定します。デフォルトではNAとなっています。 appendは，既存のファイルに追記するかどうかを指定します。基本は上書きなので，FALSEにしておきます。\n\nwrite_csv(df_left, file = \"df_left.csv\")\n\nこれで，作業ディレクトリにdf_left.csvが保存されました。 分析を進める際は，このようにして保存したデータを読み込んで使います。"
  },
  {
    "objectID": "Empoli_Chap06.html#変数の可視化視覚化",
    "href": "Empoli_Chap06.html#変数の可視化視覚化",
    "title": "6  記述統計とデータの可視化・視覚化",
    "section": "6.2 変数の可視化・視覚化",
    "text": "6.2 変数の可視化・視覚化\nカテゴリー変数のファクター化，with()関数とtable()関数を使ったクロス集計表の作成，group_by()関数とsummarize()関数を使ったグループごとの統計量の計算について学んだので，これらの結果を使ってグラフを作ることで，読者に伝わるデータの可視化を行いたいと思います。 キレイなグラフを比較的簡単に作ることができるggplot2パッケージを使います。\n\n6.2.1 ggplot()関数の基本的な使い方と変数の特徴把握\nggplot2パッケージのggplot()関数は，次のような引数をとります。\n\ndata = : データフレーム\nmapping = aes() : グラフの構成要素を指定する関数\ngeom_*** : グラフの種類を指定する関数\n各種オプション\n\n最初の注意点として，ggplot()関数は，第1引数data =でtibbleかdata.frameを指定する必要があります。 データの型に気をつけましょう。\nでは，年度ごとに平均ROEを示した折れ線グラフを作図していきます。 まず土台となるデータフレームを指定します。\n\nggplot(data = df_year)\n\n\n\n\n土台ができましたが，まだ何も表示されていません。 次に，グラフの構成要素を指定するために，mapping = aes()で，軸を指定します。 今回は，横軸に年度，縦軸に平均ROEを指定します。\n\nggplot(data = df_year, mapping = aes(x = 年度, y = 平均ROE))\n\n\n\n\n縦軸と横軸が表示されました。 軸のラベルが文字化けしているので，最初に作成しておいたスタイルmystyleを適用します。\n\nggplot(data = df_year, mapping = aes(x = 年度, y = 平均ROE)) + mystyle\n\n\n\n\n次に，グラフを作成するために，geom_line()関数を使います。 ggplot関数では，次のようなgeom_***()関数を使って，グラフの種類を指定します。\n\ngeom_point() : 散布図\ngeom_line() : 折れ線グラフ\ngeom_bar() : 棒グラフ\ngeom_boxplot() : 箱ひげ図\ngeom_histogram() : ヒストグラム\ngeom_density() : カーネル密度推定図\ngeom_violin() : バイオリンプロット\ngeom_smooth() : 平滑化曲線\n\nここでは横軸が年度という文字列，縦軸が平均ROEという量的変数となるグラフを作るので，geom_bar()を使います。\n\nggplot(data = df_year, mapping = aes(x = 年度, y = 平均ROE)) +\n  geom_bar(stat = \"identity\") + mystyle\n\n\n\n\n横軸が順序に意味のある変数であれば，geom_line()で折れ線グラフを作るほうが良いでしょう。 この場合，年度は文字列ですが，本来は順序に意味のあるカテゴリー変数ですので，factor()関数を使って，ファクター型に変換します。\n\ndf_year &lt;- df_year %&gt;%\n  mutate(年度f = factor(年度,\n  levels = c(1999:2022),\n  ordered = TRUE))\n\n横軸が順序付きのファクターの年度fとなったので，geom_line()を使って折れ線グラフを作成します。 ここで，オプションとして，group = 1を指定して，データ全体が1つのグループであることを明示します。 横軸がファクター型であるときは，group = 1をつける，というおまじないを覚えておきましょう。\n\nggplot(data = df_year, mapping = aes(x = 年度f, y = 平均ROE, group = 1)) +\n  geom_line() + geom_point() +\n  xlab(\"年度\") + ylab(\"平均ROE\") + mystyle\n\n\n\n\n上のコードは，必要な引数を省略せずに書きましたが，省略できるものを省略しつつ， すべての要素を+でつなぐよりも，レイヤーごとに代入していくほうが，コードが読みやすくなります。\n\ng &lt;- ggplot(df_year) + aes(年度f, 平均ROE, group = 1) # 基本要素\ng &lt;- g + geom_line() + geom_point() # 折れ線グラフと散布図\ng &lt;- g + xlab(\"年度\") + ylab(\"平均ROE\") + mystyle # 見た目の調整\nprint(g)\n\n\n\n\n\n\n6.2.2 ヒストグラム\n次に，前年度のROEのヒストグラムを作成してみましょう。\n\ng &lt;- ggplot(df) + aes(ROE) + geom_histogram() + xlim(-1,1) + mystyle\nprint(g)\n\n\n\n\n\n\n6.2.3 箱ひげ図とバイオリンプロット\n次に，上場場所別ROEの分布を箱ひげ図とバイオリンプロットで比較してみましょう。 箱ひげ図は，geom_boxplot()を使います。\n\ng &lt;- ggplot(df) + aes(x = factor(上場コード), y = ROE) + geom_boxplot() + mystyle\nprint(g)\n\n\n\n\nROEのばらつきが大きく，極端にROEが大きかったり小さかったりする異常値のせいで，箱ひげ図がうまく描写されていません。 そこで異常値を除外するため，ROEの範囲を[-0.5,0.5]に限定してみましょう。 先ほど箱ひげ図を作成するために作ったオブジェクトgにylim()を追加して，Y軸の範囲を指定します。\n\ng &lt;- g + ylim(-.5,.5)\nprint(g)\n\n\n\n\n箱ひげ図の箱の下辺は第1四分位(Q1)で，上辺は第3四分位(Q3)です。 真ん中の太い横棒は中央値です。 箱から出ているひげはデータの四分位範囲を超えた値の範囲ですが，黒丸は外れ値を表しています。\n次に，バイオリンプロットを作成します。 バイオリンプロットもほぼ箱ひげ図と同じですが，geom_violin()を使います。\n\ng &lt;- ggplot(df) + aes(x = factor(上場コード), y = ROE)\ng &lt;- g + geom_violin() + ylim(-.5,.5) + mystyle\nprint(g)\n\n\n\n\n箱ひげ図やバイオリンプロットから，東証1部と東証2部の上場企業のROEは中央値に差があるものの，分布の形は似ていますが，マザーズの企業は，ROEの分布が大きく異なることがわかります。\n\n\n6.2.4 図の保存\n最後に，作成した図を保存するには，ggsave()関数を使います。 ggsave()関数は，次のような引数をとります。\n\nfilename = : 保存するファイル名\nplot = : 保存する図\nwidth = : 図の幅\nheight = : 図の高さ\ndpi = : 解像度\n\n日本語を含まないグラフであったり，Windowsならこれでうまくいくのですが，Macで日本語を含むggplotのグラフを保存するには一手間必要です。\n\nMacの場合\nMacの場合，ggsave()関数を使っても，日本語が文字化けしてしまいます。 そこでquartz()関数を用いて，次のようにすれば，日本語を含むグラフを保存することができます。 quartz()は以下の引数を取ります。\n\nfilename = : 保存するファイル名\nwidth = : 図の幅\nheight = : 図の高さ\npointsize = : フォントサイズ\nfamily = : フォントファミリー\ntype = : ファイルタイプ\nantialias = : アンチエイリアス\n\n\nquartz(\"violin_plot.pdf\", width = 10, height = 6, pointsize = 10)\nprint(g)\n\n\n\ndev.off()\n\nquartz_off_screen \n                2 \n\n\nこれで作業ディレクトリにviolin_plot.pdfが保存されました。"
  },
  {
    "objectID": "Empoli_Chap07.html#母集団と標本",
    "href": "Empoli_Chap07.html#母集団と標本",
    "title": "7  統計的推定",
    "section": "7.1 母集団と標本",
    "text": "7.1 母集団と標本\n経営に関連する事象すべての中から，興味のある研究対象を絞り込むことで，リサーチクエスチョンが定まります。 例えば，消費者の消費行動に関心があるなら，消費者全体が研究対象となり，経営者の裁量的行動に関心があるなら，経営者全員が研究対象となります。 このような明確に定義された研究対象全体を母集団(population)といいます。\nしかし母集団全体に対して調査・分析することは，時間や費用の面で実質不可能です。 そのため，母集団がもつ特徴は実際に観察することはできません。\nそこで現実的に調査・分析できる範囲の標本(sample)を母集団から抜き出します。 この抽出作業をサンプリング(sampling)といい，様々なサンプリング方法があります。 また標本として選ばれる個体(unit)の数を標本サイズ(sample size)といいます。 社会科学では，通常サンプルは1度しか取らないので，サンプルの数は1となります。サンプル数というと，通常はサンプルの数のことを意味しているので，標本サイズの意味でサンプル数と言わないように気をつけましょう。\n統計学とは，いかに小さな標本から，母集団がもつ特徴(これを母数とかパラメータとよぶ)を調べることについて考える学問です。 自分で作ったお味噌汁の味を確かめるために，お味噌汁をすべて飲むのではなく，しっかりかき混ぜたうえで，スプーン一匙飲めば，全体の味を推定できることと同じです。\n標本の特徴を調べることで，観察できない母集団の母数(parameter)を予想することを，統計的推定(statistical inference)といいます。 母数が存在し，何らかの値であることは分かっているけれど，観察できない数値なので，入手可能な情報を駆使して，その未知である母数を予想したいのです。\n標本のデータを使って計算された値を統計量(statistic)とよびます。 たとえば，標本平均(sample mean)や標本分散(sample variance)などです。 この統計量の中で，母数の推定のために利用されるものを推定量(estimator)といいます。\n母数は定数ですが，推定量は標本が変われば値が変わるので確率変数です。1つの標本から計算された標本平均は，たまたま今手元にある標本から計算された平均にすぎず，別の標本を集めて標本平均を計算すれば，異なる値になることが予想されます。\n\n\n\n\n\n\n用語の意味\n\n\n\n\n母集団：研究対象となるすべての集合\n標本：母集団から抽出されたデータ\n標本サイズ：標本に含まれるデータの個数\n標本数・サンプル数：標本の数，標本サイズのことじゃないよ\n母数：母集団を特徴付ける値\n統計量：標本を特徴付ける値\n推定量：母数の推定に使われる統計量\n統計的推定：推定量から母数を予想すること\n\n\n\nまた母数を推定するために用いられる統計量と一般的な数式記号は以下の通りです。\n\n\n\n母数\n記号\n統計量\n記号\n\n\n\n\n母平均\n\\mu\n標本平均\n\\bar x\n\n\n母比率\n\\pi\n標本比率\np\n\n\n母分散\n\\sigma^2\n標本分散 (標本不偏分散)\ns^2 (u^2)\n\n\n母標準偏差\n\\sigma\n標本標準偏差\ns\n\n\n\n標本から母数を推定するためには，適切な方法で標本を集めなければなりません。 1限の講義に出席している学生にアンケートをとっても，学生全体の推定には適切とはいえない標本があつまるでしょう。\n母集団から標本を選ぶ標本抽出方法として代表的なものが，単純無作為抽出(simple randome sampling)です。 たとえば，平均10，分散1の正規分布からランダムに1000個のデータを抽出して標本を作り，その平均値を計算してみます。\n\nn = 1000\nx &lt;- rnorm(n, 10, 1)\nmean(x)\n\n[1] 10.00073\n\n\n平均値は10.000734となり，母平均1とほぼ同じ値になりました。 ## 標本分布"
  },
  {
    "objectID": "Empoli_Chap07.html#標本分布",
    "href": "Empoli_Chap07.html#標本分布",
    "title": "7  統計的推定",
    "section": "7.2 標本分布",
    "text": "7.2 標本分布"
  },
  {
    "objectID": "Empoli_Chap07.html#母平均の推定と信頼区間",
    "href": "Empoli_Chap07.html#母平均の推定と信頼区間",
    "title": "7  統計的推定",
    "section": "7.2 母平均の推定と信頼区間",
    "text": "7.2 母平均の推定と信頼区間"
  }
]